#!/usr/bin/perl

use warnings;
use strict;
# use Test::More tests => 5;
use Net::OpenID::Consumer;

use lib 't/lib';

sub fake_verified_identity {
    # extremely simplified version that only looks at .mode and .identity
    # and does not do any discovery/check_authentication callouts
    my $csr = shift;
    return $csr->_fail("bad_mode") unless $csr->_message_mode && $csr->_message_mode eq "id_res";
    return $csr->_fail("no_identity")
      unless my $id = $csr->message('identity');

    # pretend everything worked
    my $v = Net::OpenID::VerifiedIdentity->new(consumer => $csr, signed_fields => {});
    $v->{'identity'} = $csr->message('identity');
    return $v;
}

{
    no warnings 'redefine';
    *Net::OpenID::Consumer::verified_identity = \&fake_verified_identity;
}

my $the_log = '';

my @common_callbacks = (
      not_openid => sub { $the_log .= '!NOT'; },
      cancelled  => sub { $the_log .= '!CAN'; },
      verified   => sub { my $url = $_[0]->url; $the_log .= "!VER($url)"; },
      error      => sub { $the_log .= "!ERR('$_[0]: $_[1]')"; },
  );
my $the_csr;
my @handlers = (
   hsr => sub {
      $the_csr->handle_server_response(
         @common_callbacks,
         setup_required => sub { my $u = $the_csr->user_setup_url || ''; $the_log .= "!IMM($u)"; },
        );
 },
   hsr_old => sub {
      $the_csr->handle_server_response(
         @common_callbacks,
         setup_required => sub { my $u = shift || ''; $the_log .= "!IMM($u)"; },
        );
 },
   diy => sub {
      # current DIY code
      if ($the_csr->setup_needed) {
         $the_log .= "!IMM()";
    }
      elsif ($the_csr->user_cancel) {
         # restore web app state to prior to check_url
         $the_log .= "!CAN";
    }
      elsif (my $vident = $the_csr->verified_identity) {
         my $url = $vident->url;
         $the_log .= "!VER($url)";
    }         
      else {
         my $e = "'" . $the_csr->err . "'";
         $the_log .= "!ERR($e)";
    }
 },
   diy_old => sub {
      # DIY code from 1.03 synopsis
      if (my $url = $the_csr->user_setup_url) {
         $the_log .= "!IMM($url)";
    }
      elsif ($the_csr->user_cancel) {
         # restore web app state to prior to check_url
         $the_log .= "!CAN";
    }
      elsif (my $vident = $the_csr->verified_identity) {
         my $url = $vident->url;
         $the_log .= "!VER($url)";
    }         
      else {
         my $e = "'" . $the_csr->err . "'";
         $the_log .= "!ERR($e)";
    }
 },
);

my @messages =
  qw(
    immed_fail_1
      openid.mode=id_res&openid.user_setup_url=http://setup.com
    immed_fail_2
      openid.mode=setup_needed
    immed_fail_2s
      openid.mode=setup_needed&openid.user_setup_url=http://setup.com
    cancel
      openid.mode=cancel
    badverify
      openid.mode=id_res
    verify
      openid.mode=id_res&openid.identity=http://io.com/rufus
    provider_error
      openid.mode=error&openid.error=on_strike
  );
my $i;
my %messages = @messages;
@messages = do { $i=0; grep {++$i % 2} @messages };

my %handlers = @handlers;
@handlers = do { $i=0; grep {++$i % 2} @handlers };


# Nonsense combinations
my %nonsense = map {($_,1)} qw(1immed_fail_2 1immed_fail_2s 1provider_error 2immed_fail_1);


sub try {
    my ($hkey,$msg,$vm,$v2c,$expect) = @_;
    print '# '
      if ($nonsense{($vm  ? substr($vm,0,1) : '1') . $msg});
    $the_csr = Net::OpenID::Consumer->new
      (
       $v2c ? (minimum_version => 2) : (),
       args => { (!$vm ? () : ("openid.ns", ($vm >= 2 ? "http://specs.openid.net/auth/$vm" : "http://openid.net/signon/$vm"))),
                 map {split '='} split '&',$messages{$msg}
               },
      );
    $the_log = $the_csr->{message}->{minimum_version} . $the_csr->{message}->{protocol_version};
    $handlers{$hkey}->();
    print "is(try(",sprintf('%9s,%16s,%5s,%5s',map {defined($_) ? "'$_'" : 'undef'} @_),"),'$the_log');\n";
}

for my $m (@messages) {
    for my $vm ('1.1') {
        for my $v2c (undef, '2.0') {
            for my $h (@handlers) {
                try($h,$m,$vm,$v2c);
            }
        }
    }
}


1;
