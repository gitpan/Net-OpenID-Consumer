#!/usr/bin/perl

use warnings;
use strict;
use Test::More;

use LWP::UserAgent;
use Cache::Memory;
use Net::OpenID::Consumer;
use HTML::TreeBuilder;
use HTTP::Request::Common;
use Plack::Request;
use HTTP::Message::PSGI;

# do_login('google',USER,PASSWD);
# "browser" user agent
{
    package _MyUA;
    BEGIN { our @ISA = qw(LWP::UserAgent); }
    sub redirect_ok {
        my ( $ua, $prospective_request, $response ) = @_;
        my $uri = $prospective_request->uri;
        print STDERR "... $uri\n";
        return 1 if (!$ua->{stop_re} || $uri !~ $ua->{stop_re});
        $ua->{stop_request} = $prospective_request;
        return '';
    }
    sub req_until {
        my ($ua, $stop_re, @rest) = @_;
        undef $ua->{stop_request};
        local $ua->{stop_re} = $stop_re;
        my $res = $ua->request(@rest);
        return $ua->{stop_request} ? ($ua->{stop_request}) : (undef,$res);
    }
}
our $b_ua = _MyUA->new
  ( cookie_jar => {},
    timeout => 10 
  );

our %hosts = 
  (
   google => 
   {
    form_uri => 'https://accounts.google.com/ServiceLogin?hl=en&continue=https://www.google.com/',
    form_id => 'gaia_loginform',
    },
   lj => { form_uri => 'http://wrog.livejournal.com' }
  );
       
sub get_form {
    my $content = shift;
    my $tree = HTML::TreeBuilder->new;
    $tree->parse($content);
    my $form = $tree->look_down(@_ ? @_ : ('_tag','form'));
    $form->detach() if ($form);
    $tree->delete;
    return $form;
}

sub form2uri {
    my ($form, $base, $isub) = @_;

    my @inputs = $form->look_down('_tag', 'input');
    my $uri = URI->new_abs($form->{action}, $base);
    my @qparams = map {!$_->{name} ? () : $_->{type} eq 'hidden' ? ($_->{name},$_->{value}) : $isub->($_)} @inputs;
    my $method = lc($form->{method});
    if ($method eq 'get') {
        $uri->query_form(@qparams);
        return ($method,$uri);

    }
    elsif ($method eq 'post') {
        return ($method,$uri,{@qparams});
    }
    else {
        die "unknown method ".$method;
    }
}

sub do_login {
    my ($hkey,$text,$pwd) = @_;
    my $r = $b_ua->get($hosts{$hkey}->{form_uri});
    return ('loginpage',$r->code )
      unless $r->code == 200;
    return ('no_form')
      unless my $form = get_form($r->content, ($hosts{$hkey}->{form_id} ? (id => $hosts{$hkey}->{form_id}) : ()));

    my ($method, @params) = form2uri
      ($form, $hosts{$hkey}->{form_uri}, 
       sub {
           my $i = shift;
           return ($i->{name},
                   ($i->{type} eq 'text' ? $text : $i->{type} eq 'password' ? $pwd : $i->{value}));
       });                                         
    $form->delete;
    my $r2 = $b_ua->$method(@params);
    return ($r2->code == 200 ? () : ('fail',$r2->code,$r2));
}

# "server" user agent
our $s_ua = LWP::UserAgent->new
  ( timeout => 10 
  );

our $cache = Cache::Memory->new;

our $csr = Net::OpenID::Consumer->new
  (
   ua => $s_ua,
   cache => $cache,
   consumer_secret => 'freeze-dried-wombats',
   required_root => "http://site.example.com/",
  );

# doid1(... , 'http://example.com/','openid-check.app?yourarg=val')
# $b_ua->{stop_here} = qr|^https?://[a-z\.]*\bexample\.com|;

sub doid1 {
    my ($oid, $return_base, $to, $delay) = @_;
    # a user entered, say, "bradfitz.com" as their identity.  The first
    # step is to fetch that page, parse it, and get a
    # Net::OpenID::ClaimedIdentity object:

    my $claimed_identity = $csr->claimed_identity($oid);

    return ("NO_ID",$csr->err) unless $claimed_identity;

    # now your app has to send them at their identity provider's endpoint
    # to get redirected to either a positive assertion that they own
    # that identity, or where they need to go to login/setup trust/etc.

    my $check_url = $claimed_identity->check_url
      (
       return_to  => "${return_base}${to}",
       trust_root => $return_base,
       ($delay ? (delayed_return => 1) : ()),
      );

    # so you send the user off there, and then they come back to
    # openid-check.app, then you see what the identity provider said.

    my ($req,$res) = $b_ua->req_until(qr(^$return_base), GET $check_url);
    $csr->args(Plack::Request->new(HTTP::Message::PSGI::req_to_psgi($req)))
      if $req;
    return !$req && $res;
}

sub hsr {
    # Either use callback-based API (recommended)...
    $csr->handle_server_response
      (
       not_openid => sub {
           return "NOTOPENID";
       },
       setup_needed => sub {
           # (openID 1) redirect user to $csr->user_setup_url
           # (openID 2) retry request in checkid_setup mode
           return "SETUP: ".($csr->user_setup_url || 'nada');
       },
       cancelled => sub {
           return "CANCEL";
       },
       verified => sub {
           my $vident = shift;
           # Do something with the VerifiedIdentity object $vident
           return ("VERIFIED",$vident);
       },
       error => sub {
           return ("ERROR", shift);
       },
      );
}

1;
